# 3.2 GridDB

GridDB ist eine verteilte hochskalierbare NoSQL-Zeitreihendatenbank. Sie weist eine sehr hohe Performanz auf und ist für *IoT* (kurz für: *Internet of Things*) sowie Big Data optimiert [GridDB DB-Engine]. GridDB wird von Toshiba Corporation seit 2011 entwickelt. Der erste kommerzielle Release war 2013. 2016 wurde der Quellcode öffentlich zur Verfügung gestellt. [1]

## Datenmodell/-struktur

### Key-Value-Store

GridDB integriert eine der vier NoSQL-Technologien: den Key-Value-Store. Dabei handelt es sich um eine Datenbank mit eindeutigen Schlüsseln und zugeordneten Werten. Da die Key-Value-Stores mit ihren Schlüssel-Werte-Paaren einfache Strukturen haben und sie den Arbeitsspeicher von Rechnern nutzen (In-Memory), können ihre Datensätze ressourcenschonend sehr schnell geschrieben und gelesen werden. Sie können als volatiler Zwischenspeicher zur Optimierung von Applikationen und zur Reduzierung der Zugriffszeiten eingesetzt werden. Key-Value-Datenbanken können einfach sklaliert werden und eignen sich aus diesem Grund für das Cloud-Computing [E. Schicker, Datenbanken und SQL]. [D. Fasel und A. Meier, Big data][Key-Value-Store, DB-Engine]

Key-Value-Stores gelten als schemalose Datenbanken. Der Schlüsselraum kann zwar mittels Sonderzeichen wie Doppelpunkten oder Schrägstrichen rudimentär strukturiert werden. Ansonsten unterstützen Key-Value-Datenbanken keinerlei Strukturen, Referenzen oder Verschachtelungen. Datenobjekte können jederzeit in beliebigen Formaten gespeichert werden, ohne die Notwendigkeit eines vorab festgelegten Formats. Dies erhöht die Flexibilität von Key-Value-Datenbanken, beschleunigt die Abfragen und erleichtert die Partitionierung.

Eine Key-Value-Datenbank weist folgende Eigenschaften auf:
- Es gibt Datenobjekte, die zur Identifikation eingesetzt werden: die Schlüssel.
- Jedem Schlüssel wird ein Datenobjekt zugewiesen, das dessen Wert beschreibt.
- Unter Angabe des Schlüssels können die zugewiesenen Werte abgefragt werden.  

Die hohe Schreib- und Lesegeschwindigkeit kann einerseits dadurch erreicht werden, dass auf die Prüfung der *referentiellen Integrität* verzichtet wird, wonach in RDBMS die Beziehungen zwischen Datenobjekten kontrolliert werden. Andererseits kann die Performanz noch weiter gesteigert werden, indem die Schlüssel-Werte-Paare im Hauptspeicher der Datenbank zwischengespeichert werden. Key-Value-Stores sind In-Memory-Datenbanken. Sie verwenden Technologien, die Werte im Hauptspeicher puffern können, während diese permanent mit den persistenten Langzeit-Daten im Hintergrundspeicher überprüft werden.  
Durch das simple Datenmodell der Key-Value-Stores ist die Partitionierung sehr einfach. Einzelne Computer eines Clusters, die *Shards*, übernehmen einen Teil des Schlüsselraums. Dadurch kann die Datenbank auf mehrere Maschinen verteilt werden. Die Verteilung der Schlüssel erfolgt nach dem Prinzip des *Consistent Hashing* (engl. für: *Konsistente Hashfunktion*). Danach wird eine Speicheradresse oder ein Hashwert aus einem Satz von Schlüsseln berechnet, um einen neuen entsprechenden Datensatz zu speichern. Gemäß dessen werden in Big-Data-Anwendungen Schlüssel-Werte-Paare verschiedenen Knoten in einem Computernetzwerk zugeordnet. Ausgehend von den Schlüsseln werden deren Werte in den zugehörigen Knoten gespeichert. Mittels *Consistent Hashing* wird die Adressberechnung sowohl für die Knotenadressen als auch für die Speicheradressen der Datenobjekte verwendet (Key-Value).

[X] A. Meier und M. Kaufmann, SQL & NoSQL Databases (S. 202-205)


### Key-Container

Bei der GridDB wird die typische NoSQL-Technologie des Key-Value-Stores erweitert. Die unten stehende Abbildung zeigt unterschiedliche Datenmodelle im direkten Vergleich. Auf die in der Abbildung erwähnten Datenmodelle Key-Column und Key-Document wird hier nicht näher eingegangen. *Key-Value* wurde als Ausgangsbasis von GridDB bereits oben beschrieben. Das Datenmodell *Key-Container* ist eine Erweiterung des Key-Value-Stores und ist das von GridDB eingesetzte Datenmodell. [Imru]

![Datenmodelle im Vergleich](../images/key-value_key-container.jpg)
***Abbildung:** Datenmodelle im Vergleich: Key-Value, Key-Column, Key-Document und Key-Container* [Imru]

GridDB verwaltet Daten auf der Basis von *Blöcken*, *Containern* (*Tabellen*), *Reihen*, *Partitionen* und *Partitionsgruppen*. Ein *Block* ist eine Dateneinheit für die Verarbeitung persistenter Daten auf einem Festplattenspeicher. Es ist die kleinste physische Einheit der Datenverwaltung in einer GridDB. Mehrteilige Containerdaten werden in einem Block angeordnet. Die Blockgröße kann entweder 64 KB oder 1 MB betragen.  
Ein *Container* ist eine Datenstruktur, die als Oberfläche für den Nutzer dient. Er besteht aus mehreren Blöcken. Ein Block wird *Container* genannt, wenn auf Basis von *NoQL* gearbeitet wird, und *Tabelle*, wenn auf Basis von *NewSQL* gearbeitet wird. *NewSQL* bezieht sich auf Datenbankmanagementsysteme, die die Vorteile von klassischen RDBMS und NoSQL verbinden möchte. Es gibt zwei Datentypen: *Collection* (*Tabelle*) und *Time Series Container* (*Time Series Tabelle*).  
Eine *Row* (engl. für *Reihe*, auch *Zeile*) bezieht sich auf eine Datenzeile, die in einem Container eingetragen wird. Abhängig von der Eintragung und der Zeiteinteilung, werden die Daten in den passenden Blocks innerhalb von Partitionen. In der Regel gibt es Spalten mit mehreren Datentypen in einer Zeile.  
Eine *Partition* ist eine logische Datenverwaltungseinheit, die eine oder mehrere Container beinhaltet. Zwischen Clustern dient sie zur Verwaltung der Datenbewegungen, zur Regelung der Lastverteilung zwischen den Knoten sowie zur Mehrfachhaltung von Daten im Falle einer Störung. Eine *Partitionsgruppe* besteht auf mehreren Partitionen. [GridDB technical reference]

Bei dem Datenmodell des *Key Containers* werden Daten in Form einer *Collection* (engl. für: Kollektion, Sammlung) abgebildet und durch einen *Key* (engl. für: *Schlüssel*) referenziert. Dieses Prinzip kann in etwa dem von relationalen Datenbanken gleichgesetzt werden. Der *Key* entspricht dabei dem Tabellennamen und die *Collection* den Tabellendaten, die in einem *Container* zusammengefasst sind (vgl. unten stehende Abbildung). Auf diese Art können die Daten in einem Schema strukturiert werden, ähnlich wie in einer relationalen Datenbank. [3]

![Datenmodell mit Key-Container](../images/key-container_data-type.jpg)
***Abbildung:** Datenmodell mit Key-Container* [3]

In der GridDB werden sowohl *Collections* als auch *Time Series Container* unterstützt. Während für *Collections* beliebige Werte als *Keys* eingesetzt werden, verwenden *Time Series Container* einen *Zeit-Wert*. Auf diese Weise ist die Speicherung und der Zugang zu Meta-Informationen von Zeitreihen leichter zu handhaben, da der Wechsel zwischen verschiedenen APIs und Verbindungen entfällt. [3]  
Darüber hinaus können neben speziellen API-Aufrufen auch Abfragen über den Schlüssel durchgeführt werden, Zeitintervalle begrenzt werden oder Daten aus einem festgelegten zurückliegenden Zeitraum automatisch gelöscht werden. [Imru]

GridDB gilt als eine der schnellsten NoSQL-Datenbanken. Das liegt unter anderem daran, dass GridDB ebenso wie Key-Value-Datenbanken das In-Memory-Prinzip nutzt. Das alleinige Halten der Daten im flüchtigen Speicher reicht allerdings nicht aus. Wenn große Datenmengen verarbeitet werden sollen, sollte ein DBMS ebenso in der Lage sein, diese persistent auf Festplatten zu speichern. Um die Festplattenzugriffe so weit wie möglich zu reduzieren, werden Daten lokal begrenzt. Zu diesem Zweck platziert GridDB zusammenhängende Daten im selben Datenblock. Mittels *Hint*-Informationen (hint, engl. für: *Hinweis*) über die Daten stellt GridDB entsprechende Datenblöcke zusammen. Auf diese Weise werden fehlschlagende Speicherzugriffe reduziert und die Leistung verbessert. [Imru]

![Combined use of in-memory/disk](../images/feature_disk_and_memory.png)
***Abbildung:** GridDB-API-Processing mit In-Memory* [GridDB technical reference]




## Partionierungsmechanismen

### Architektur
GridDB hat eine hybride Cluster-Architektur, die die *Peer-to-Peer-* und *Leader/Follower*-Technologien (neu für: *Master/Slave*) kombiniert. Alle Knoten eines Clusters sind identisch und ein Knoten wird entsprechend eines Algorithmus zum Master (Leader) gewählt. Der *Master-Knoten* und *Follower-Knoten* tauschen *Heartbeat*-Nachrichten (engl. für: Herzschlag) aus, um damit gegenseitig ihre Betriebsbereitschaft signalisieren. Der *Master-Knoten* ist der Besitzer der Partitionstabelle, welche an die *Follower-Knoten* weitergegeben und kopiert wird. Der Besitzer einer Partition hat Lese- und Schreibrechte, während das Backup lediglich lesende Operationen zulässt. Fällt der Master-Knoten aus, wird einer der Follower-Knoten mittels Algorithmus zum Master-Knoten gewählt. Da alle Follower-Knoten eine Kopie der Partitions-Tabelle besitzen, kann der Cluster innerhalb weniger Sekunden die normalen Operationen fortsetzen. [GridDB Reliability and Robustness]



![GridDB Architecture](../images/griddb_in-memory.jpg)
***Abbildung:** Combined use of in-memory/disk* [Imru]


## Replikationsmechanismen


## Unterstützte Programmiersprachen
GridDB wurde in C++ geschrieben und unterstützt darüber hinaus die Programmiersprachen C, Java, Python, Go, Node.js und Ruby. [1][2][3]

The Key Container model allows high speed access to data through Java and C APIs. Data in GridDB can be queried through SQL. Additionally, basic search through the WHERE command and high speed conditional search operations through indexing offer a great advantage for applications that rely on faster search. GridDB supports transactions, including those with plural records from the application. [3]

Datenbank-Sprachen: SQL, TQL, JDBC

## APIs und andere Konzeptzugriffe

## Einsatzbereiche
Factory IoT
Automative Industry
Energy
BEMS
Smart Community
Monitoring system


## Vorteile, Besonderheiten und Nachteile 

Transactions in GridDB guarantee ACID (Atomicity, Consistency, Isolation, and Durability) at the container level. [3]


## Literaturverzeichnis

[1] O. Stampflee, NoSQL Database Architectural Comparison. [Online]. Verfügbar unter: https://griddb.net/en/docs/NoSQL_Database_Architectural_Comparison.pdf.

[2] J. Pascascio, „Using GridDB’s C/Python/Ruby APIs“, Fixstars, 21. Sep. 2017, 2017. [Online]. Verfügbar unter: https://griddb.net/en/blog/using-griddbs-cpythonruby-apis/. Zugriff am: 21. Dezember 2021.

[3] GridDB Products | GridDB | TOSHIBA DIGITAL SOLUTIONS CORPORATION. [Online]. Verfügbar unter: https://www.global.toshiba/ww/products-solutions/ai-iot/griddb/product/lineup.html (Zugriff am: 21. Dezember 2021).

[?] Key-Value Stores - DB-Engines Enzyklopädie. [Online]. Verfügbar unter: https://db-engines.com/de/article/Key-Value+Stores (Zugriff am: 25. Dezember 2021).

[?] I. Imru, „Time Series Data and GridDB - GridDB - Medium“, GridDB, 27. Feb. 2019, 2019. [Online]. Verfügbar unter: https://medium.com/griddb/time-series-data-and-griddb-abc9c26f91de. Zugriff am: 4. November 2021.

[?] GridDB technical reference. [Online]. Verfügbar unter: https://www.toshiba.com/solutions/content/GridDB_TechnicalReference.html (Zugriff am: 29. Dezember 2021).

[?] GridDB Reliability and Robustness. [Online]. Verfügbar unter: https://griddb.net/en/docs/GridDB_Reliability_and_Robustness_1.0.7.pdf (Zugriff am: 30. Dezember 2021).
